媒体能力设计
参考Dshow和Gst
但二者都有不足,拿Gst来说

模块1能力集{A,B,C,D,E}和模块2能力集{C,E}协商出的结果到底是C还是E,如果你更倾向于E,那你就要去设置个能力过滤器
这样我们还要去看模块1和2的能力集，自己算一下会产生什么。然后插入我们更倾向于产生的过滤器。这还要代码自动协商干什么?
如果你不指定产生的最终能力,结果就变得不预知,我希望做一个可预知的能力协商模型。

比如模块1的能力集是{A,B,C,D,E}而模块2是{C,E}。求交集之前我们将模块1排序,排序函数由用户提供。排序完成后期望值由大变小。
比如变成{E,D,C,B,A},模块2不变。交集后模块1剩下{E,C},而模块2剩下{C,E},双方最期望的值不同。因此用户必须指定谁是主谁是辅,
这里模块1是主,结果就是E。反之C。

当然能力的描述并不是上述的几个枚举型值。Gst和DShow的能力描述也不能够贴合实际需求。

比如某音频播放插件。能力是PCM,S16,8000HZ,单声道和PCM,S32,4000HZ,双声道
Gst的能力描述会把格式融合为两种。频率融合为两种。这样得到一个能力
PCM,{S16,S32},{8000hz, 4000hz},双声道,这就错了。4000HZ只在S32的格式下才生效。能力集应该被设计成树。像这样

								 [PCM]
								/    \
							   /      \
							  [S16]    [s32]
							 /          \
						[8000]		   [双声道]  
						   /		    /      \
					[单声道]		[4000]	   [2000]	
					
同时在代码里更容易的表达能力,json字符串用来转换到能力集,因为xml包含需要转义的字符,在代码里写出来太乱,可读性太差
	MeiaCaps caps1(
		"["
					"["
						"type:video"
						"codec:h264"
						"["
							"framerate:1~50"
							"bitrate:200k~4M"
						"]"
					"]"

					"["
						"type:audio"
						"codec:pcm"
						"["
							"sample_format:s16"
							"["
								"bitrate:200k~4M"
								"channel:1~2"
							"]"
						"]"

						"["
							"sample_format:s32"
							"["
								"bitrate:8M"
								"channel:2"
							"]"
						"]"

						"bitrate:20M"

					"]"
		"]"
		);